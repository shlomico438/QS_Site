{% extends "base.html" %}

{% block content %}
<div class="main-container">
    <img src="{{ url_for('static', filename='logo.png') }}" alt="QuickScribe Logo" style="width: 350px; height: auto; margin-bottom: 20px;" class="logo">
    
    <h1>Transcription made simple.</h1>
    <p class="subtitle">Precision AI transcription for high-context languages and noisy environments.</p>

    <div class="feature-box upload-zone" id="drop-zone">
        <p>Drag & Drop audio files here</p>
        <span>or</span>
        <input type="file" id="fileInput" hidden>
        <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">Browse Files</button>
        <p id="upload-status" style="margin-top: 15px; font-weight: bold;"></p>
    </div>

    <div class="feature-box zoom-zone">
        <p>Want automatic meeting notes?</p>
        <a href="/zoom/login" class="btn btn-secondary zoom-btn">Connect Zoom Account</a>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const fileInput = document.getElementById('fileInput');
    const statusTxt = document.getElementById('upload-status');
    const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB

    // Variable to store the header from the very first chunk
    let headerBlob = null;

    fileInput.addEventListener('change', async function() {
        const file = this.files[0];
        if (!file) return;

        statusTxt.innerText = "Starting upload...";
        statusTxt.style.color = "blue";

        const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
        const jobId = "job_" + Date.now(); // Adding Job ID for backend isolation
        const fileNameBase = file.name;

        for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
            let chunk = file.slice(chunkIndex * CHUNK_SIZE, (chunkIndex + 1) * CHUNK_SIZE);

            // --- HEADER LOGIC ---
            // If it's chunk 0, capture the first 1KB which contains the WebM/MP4 header
            if (chunkIndex === 0) {
                headerBlob = chunk.slice(0, 1000);
            } else if (headerBlob) {
                // For all other chunks, glue the header to the front
                // This makes every chunk a valid, playable standalone file
                chunk = new Blob([headerBlob, chunk], { type: file.type });
            }

            const formData = new FormData();
            formData.append('file', chunk);
            formData.append('jobId', jobId);
            formData.append('filename', `chunk_${String(chunkIndex).padStart(3, '0')}.webm`);

            let progressInterval;
            if (chunkIndex === totalChunks - 1) {
                let fakePercent = 90;
                progressInterval = setInterval(() => {
                    if (fakePercent < 99) {
                        fakePercent++;
                        statusTxt.innerText = `Finalizing: ${fakePercent}% (Syncing to cloud...)`;
                    }
                }, 2000);
            }

            try {
                // Ensure this matches your siteapp.py route exactly
                const response = await fetch('/api/upload_streaming_chunk', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || "Upload failed");
                }

                if (chunkIndex < totalChunks - 1) {
                    const percent = Math.round(((chunkIndex + 1) / totalChunks) * 90);
                    statusTxt.innerText = `Uploading: ${percent}%`;
                } else {
                    clearInterval(progressInterval);
                    const result = await response.json();
                    statusTxt.innerText = "Success! " + result.message;
                    statusTxt.style.color = "green";
                }
            } catch (error) {
                if (progressInterval) clearInterval(progressInterval);
                statusTxt.innerText = "Upload failed: " + error.message;
                statusTxt.style.color = "red";
                break;
            }
        }
    });
});
</script>
{% endblock %}